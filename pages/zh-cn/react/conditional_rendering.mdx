---
title: 条件渲染
---

import shortCircuitAnd from '../../../examples/files/react/shortCircuitAnd.js'
import ternaryEvaluation from '../../../examples/files/react/ternaryEvaluation.js'
import complexRendering from '../../../examples/files/react/complexRendering.js'

## 基于 `props` 参数渲染

React 组件基于传入的 `props` 参数，来渲染完全不同类型的元素的做法，也是很常见的。

React 在这方面的灵活度很高，在每次调用函数组件的时候都可以返回完全不同的元素树。

> 换句话说，如果我们要隐藏一个组件，只要在元素树排除中它即可。

---

## React 节点

从函数组件返回的不局限于 React 元素，以下的数据类型都有效：

- React 元素
- `false`, `null`, 或者 `undefined` （什么都不渲染）
- 包含上述数据类型的数组
- React Portal (传送门)

> 如果你使用的是 TypeScript，`React.ReactNode` 包括上述所有数据类型。

---

## Rendering with `&&`

One of the most common cases: conditionally rendering a React element based on whether a specific `prop` is true or not. <Details>In this example, we'll render a Card component that takes a `title` prop and optionally a `showButton` prop. We only want to render a `Button` for the subtitle if it exists.</Details>

> The same technique works with `||` too.

<Example code={shortCircuitAnd} />

---

## Rendering with ternary `?`

Another common case: rendering a different React element for when a `prop` exists and when it doesn't. <Details>We can accomplish this with the ternary operator.</Details>

> Note that a buttonTitle equal to the empty string, `""`, won't render, since the empty string is a falsy value. If we did want it to, we could use `buttonTitle === undefined` to check for that case.

<Example code={ternaryEvaluation} />

---

## Rendering with `if/else`

For more complex rendering, we can introduce variables to store our React elements, letting us combine them in different ways.<Details> Let's take a look at an example where the rendering is substantially different based on whether or not the `loading` and `error` props exist.</Details>

<Example code={complexRendering} />

---

## Managing complexity

Rendering in React is powerful because the logic can be as simple or complex as we need it to be.

However, as rendering complexity grows, the code can start to become unmanageable.

**Consider breaking down complex components into smaller, simpler ones for a more maintainable code base.**
